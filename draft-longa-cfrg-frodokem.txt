



CFRG                                                          Y. N. Here
Internet-Draft                                    Your Organization Here
Intended status: Informational                             23 April 2024
Expires: 25 October 2024


         FrodoKEM: key encapsulation from learning with errors
                    draft-longa-cfrg-frodokem-latest

Abstract

   This memo specifies FrodoKEM, an IND-CCA2 secure Key Encapsulation
   Mechanism (KEM).

About This Document

   This note is to be removed before publishing as an RFC.

   The latest revision of this draft can be found at
   https://example.com/LATEST.  Status information for this document may
   be found at https://datatracker.ietf.org/doc/draft-longa-cfrg-
   frodokem/.

   Discussion of this document takes place on the WG Working Group
   mailing list (mailto:WG@example.com), which is archived at
   https://example.com/WG.

   Source for this draft and an issue tracker can be found at
   https://github.com/USER/REPO.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 25 October 2024.

Copyright Notice

   Copyright (c) 2024 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.

Table of Contents

   1.  Introduction
   2.  Conventions and Definitions
   3.  Overview
   4.  Notation
   5.  Parameters
   6.  Supporting functions
     6.1.  Octet encoding of bit strings
     6.2.  Matrix encoding of bit strings
     6.3.  Packing matrices modulo q
     6.4.  Sampling from the error distribution
     6.5.  Matrix sampling from the error distribution
     6.6.  Pseudorandom matrix generation
       6.6.1.  Matrix A generation with AES128
       6.6.2.  Matrix A generation with SHAKE128
   7.  FrodoKEM
     7.1.  Key Generation
     7.2.  Encapsulation
     7.3.  Decapsulation
   8.  FrodoKEM variants
   9.  Parameter Sets
     9.1.  Parameters
     9.2.  Aligned Table
   10. Security Considerations
   11. IANA Considerations
   12. Normative References
   Acknowledgments
   Author's Address

1.  Introduction

   FrodoKEM is a conservative yet practical post-quantum key
   encapsulation mechanism whose security derives from cautious
   parameterizations of the well-studied learning with errors problem,
   which in turn has close connections to conjectured-hard problems on
   generic, "algebraically unstructured" lattices.

   As a key encapsulation mechanism, FrodoKEM is a three-tuple of
   algorithms (_KeyGen_, _Encapsulate_, _Decapsulate_):

   *  _KeyGen_ takes no inputs, requires randomness, and outputs a
      private key and a public key;

   *  _Encapsulate_ takes as input a public key, requires randomness,
      and outputs a ciphertext and a shared secret;

   *  _Decapsulate_ takes as input a ciphertext and a private key, and
      outputs a shared secret.

   These algorithms are assembled as a two-pass protocol that allows two
   parties to derive a shared secret.  This shared secret can then be
   used to establish a secure communication channel using a symmetric-
   key algorithm.

2.  Conventions and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

3.  Overview

4.  Notation

   We describe the symbols and abbreviations used throughout this
   document.

   Z represents the set of integers and Z_q represents the set of
   integers modulo q.

   $\lfloor$ x $\rceil$ is the rounding of x to the nearest integer.  If
   x = y + 1/2 for some y in Z, then $\lfloor$ x $\rceil$ = y + 1.

   A 16-bit bit string is represented by r^(i).  And a sequence of t
   16-bit bit strings r^(i) is represented by (r^(0), r^(1), ...,
   r^(t-1)).

   AES128(k, a) denotes the 128-bit AES128 output under key k for a
   128-bit input a.

   SHAKE128(x, y) and SHAKE256(x, y) denote the y first bits of SHAKE128
   and SHAKE256 (resp.) output for input x.

   Matrices are represented in capitals with no italics (e.g., A and C).
   For an n1 * n2 matrix C, its (i,j)th coefficient (i.e., the entry in
   the ith row and jth column) is denoted by C_(i,j), where 0 <= i < n1
   and 0 <= j < n2.  The transpose of matrix C is denoted by C^T.

5.  Parameters

   The FrodoKEM parameters are implicit inputs to the FrodoKEM
   algorithms defined in the next sections.  A FrodoKEM parameter set
   specifies the following:

   A positive integer D <= 16 that defines the modulus parameter q =
   2^D.

   Positive integers n, nHat specifying matrix dimensions.  It holds
   that n, nHat \equiv 0 mod 8.

   A positive integer B <= D specifying the number of bits encoded in
   each matrix entry.

   A positive integer lenA specifying the bitlength of seeds for the
   generation of the matrix A.

   A positive integer lensec specifying the number of bits that match
   the bit-security level.  Valid values are 128, 192 and 256.  This is
   used to determine the bitlength of seeds (not associated to the
   matrix A), of hash value outputs and of values associated to the
   generation of the shared secrets.

   A positive integer lenSE specifying the bitlength of the seed value
   seedSE.

   A positive integer lensalt specifying the bitlength of the value
   salt.

   A discrete, symmetric error distribution X on Z with support given by
   S_X = {−d, −d+1, ..., −1, 0, 1, ..., d−1, d} for a small integer d.

   A table T_X = (T_X(0), T_X(1), ..., T_X(d)) with (d+1) positive
   integers based on the cumulative distribution function for X.

   The values for these parameters corresponding to each parameter set
   are given in Section XXXX.

6.  Supporting functions

6.1.  Octet encoding of bit strings

   This document follows the little-endian formatting for octet encoding
   of bit strings.

   A bit string b = (b_0, b_1, ..., b_(|b|-1)) is converted to an octet
   string by taking bits from left to right, packing those from the
   least significant bit of each octet to the most significant bit, and
   moving to the next octet when each octet fills up.  For example, the
   16-bit bit string (b_0, b_1, ..., b_15) is converted into two octets
   f and g (in this order) as

   f = b_7 * 2^7 + b_6 * 2^6 + b_5 * 2^5 + b_4 * 2^4 + b_3 * 2^3 + b_2 *
   2^2 + b_1 * 2 + b_0 g = b_15 * 2^7 + b_14 * 2^6 + b_13 * 2^5 + b_12 *
   2^4 + b_11 * 2^3 + b_10 * 2^2 + b_9 * 2 + b_8

   The conversion from octet string to bit string is the reverse of this
   process.

   For FrodoKEM, it is always the case that |b| is a multiple of 8 when
   performing octet encoding of bit strings.

6.2.  Matrix encoding of bit strings

   We define how bit strings are encoded as mod-q integer matrices.

   Recall that 2^B <= q.  The encoding function ec() encodes an integer
   0 <= val < 2^B as an element in Z_q by multiplying it by q/2^B =
   2^(D-B):

   ec(val) = val * q/2^B.

   Using this function, the function Encode(b) encodes a given bit
   string b = (b_0, ..., b_(l-1)) of length l = B * nHat^2 as an nHat *
   nHat matrix C with coefficients C_(i,j) in Z_q by applying ec(\cdot)
   to B-bit sub-strings sequentially and filling the matrix row by row
   entry-wise.  The function Encode(b) is defined as follows.

   1.  For i = 0 to nHat - 1 do

       1.  For j = 0 to nHat - 1 do

           1.  val = 0

           2.  For k = 0 to B - 1 do

               1.  val = val + b_((i*nHat + j)B + k) * 2^k

           3.  End for

           4.  Set C_(i,j) = val * q/2^B

       2.  End for

   2.  End for

   3.  Return C

   The corresponding decoding function Decode(C) decodes an nHat * nHat
   matrix C into a bit string of length l = B * nHat^2.  It extracts B
   bits from each entry by applying the function dc():

   dc(c) = $\lfloor$ c * 2^B/q $\rceil$ mod 2^B.

   That is, the Z_q-entry is interpreted as an integer, then divided by
   q/2^B and rounded.  This amounts to rounding to the B most
   significant bits of each entry.  With these definitions, it is the
   case that dc(ec(val)) = val for all 0 ≤ val < 2^B.  The function
   Decode(C) is defined as follows.

   1.  For i = 0 to nHat - 1 do

       1.  For j = 0 to nHat - 1 do

           1.  c = $\lfloor$ C_(i,j) * 2^B/q $\rceil$ mod 2^B

           2.  Set c = c_0 * 2^0 + c_1 * 2^1 + ... + c_(B-1) * 2^(B-1)

           3.  For k = 0 to B - 1 do

               1.  b_((i*nHat + j)B + k) = c_k

           4.  End for

       2.  End for

   2.  End for

   3.  Return (b_0, ..., b_(l-1)).

6.3.  Packing matrices modulo q

   We define packing and unpacking functions to transform matrices with
   entries in Z_q to bit strings and vice versa.

   The function Pack packs an n1 * n2 matrix C with entries C_(i,j) in
   Z_q to an octet string by concatenating the D-bit matrix
   coefficients.  The function Pack(C) is defined as follows.

   1.  For i = 0 to n1 - 1 do

       1.  For j = 0 to n2 - 1 do

           1.  Set C_(i,j) = c_0 * 2^0 + c_1 * 2^1 + ... + c_(D-1) *
               2^(D-1)

           2.  For k = 0 to D - 1 do

               1.  b_((i*n2 + j)D + k) = c_(D-1-k)

           3.  End for

       2.  End for

       3.  End for

   2.  Output the octet string corresponding to the bit string b = (b_0,
       b_1, ..., b_(D*n1*n2 - 1)), as per XXXX.

   The function Unpack does the reverse of this process to transform an
   octet string o to an n1 * n2 matrix C with entries C_(i,j) in Z_q,
   converting the input to a bit string, and then extracting D-bit
   strings and storing each as matrix coefficients C_(i,j) for 0 <= i <
   n1 and 0 <= j < n2 (row-by-row from C_(0,0) to C_(n1-1,n2-1)).  The
   function Unpack(o, n1, n2) is defined as follows:

   1.  Convert the input octet string o to a bit string b = (b_0, b_1,
       ..., b_(D*n1*n2 - 1)), as per XXXX.

   2.  For i = 0 to n1 - 1 do

       1.  For j = 0 to n_2 - 1 do

           1.  C_(i,j) = 0

           2.  For k = 0 to D - 1 do

               1.  C_(i,j) = C(i,j) + b_((i*n2 + j)D + k) * 2^(D-1-k)

           3.  End for

       2.  End for

   3.  End for

   4.  Output C

6.4.  Sampling from the error distribution

   The error distribution X used in FrodoKEM is a discrete, symmetric
   distribution on Z, centered at zero and with small support, which
   approximates a rounded continuous Gaussian distribution.

   The support of X is S_X = {−d, −d+1, ..., −1, 0, 1, ..., d−1, d} for
   a positive integer d.  The probabilities X(z) = X(−z) for z in S_X
   are given by a discrete probability density function, which is
   described by a table

   T_X = (T_X(0), T_X(1), ..., T_X(d))

   of d+1 positive integers related to the cumulative distribution
   function.

   Given a random bit string r = (r_0, r_1, ..., r_15), the function
   Sample(r) returns a sample e from FrodoKEM’s error distribution X via
   inversion sampling using a table T_X, as follows (note that T_X(d) is
   never accessed):

   1.  Set t = r_1 * 2^0 + r_2 * 2^1 + ... + r_15 * 2^14 \equiv (r_1,
       r_2, ..., r_15, 0), interpreted as a nonnegative integer in the
       little-endian byte order

   2.  e = 0

   3.  For i = 0 to d - 1 do

       1.  If t > T_X(i) then

           1.  e = e + 1

       2.  End if

   4.  End for

   5.  e = (-1)^(r_0) * e

   6.  Output e

   The output of the algorithm is a small integer in the range {-d,
   -d+1, ..., -1, 0, 1, ..., d-1, d}. The tables T_X corresponding to
   each of FrodoKEM’s parameter sets are given in Table XXXX.

   We emphasize that it is important to perform this sampling in
   constant time to avoid exposing timing side-channels, which is why
   the for-loop of the algorithm does a complete loop through the entire
   table T_X.  Similarly, the comparison in the if-loop needs to be
   implemented in a constant-time manner.

6.5.  Matrix sampling from the error distribution

   We define the function SampleMatrix which samples an n1 * n2 matrix
   using the function Sample.

   Given (n1 * n2) 16-bit random strings r^(i) and the dimension values
   n1 and n2, SampleMatrix((r^(0), ..., r^(n1*n2 - 1)), n1, n2)
   generates an n1 * n2 matrix E row-by-row from E_(0,0) to
   E_(n1-1,n2-1) by successively calling the function Sample n1 * n2
   times, as follows:

   1.  For i = 0 to n1 - 1 do

       1.  For j = 0 to n2 - 1 do

           1.  E_(i,j) = Sample(r^(i*n2 + j))

       2.  End for

   2.  End for

   3.  Output E

6.6.  Pseudorandom matrix generation

   The function Gen takes as input a seed, seedA, of length lenA=128
   bits and an implicit dimension n that is fixed per parameter set, and
   outputs an n * n pseudorandom matrix A, where all the coefficients
   are in Z_q.  There are two options for instantiating Gen: one based
   on AES128 and another based on SHAKE128.  In both cases, the matrix A
   is generated row-by-row from A_(0,0) to A_(n-1,n-1).

6.6.1.  Matrix A generation with AES128

   The algorithm for the case using AES128 is shown below.  Each call to
   AES128 generates 8 coefficients.

   1.  For i = 0 to n - 1 do

       1.  For j = 0 to n - 1 step 8 do

           1.  b = i||j||0||0||0||0||0||0, where each concatenated
               element is encoded as a 16-bit string represented in the
               little-endian byte order such that, e.g., (i_0, i_1, ...,
               i_15) \equiv i_0 * 2^0 + i_1 * 2^1 + ... + i_15 *\ 2^15,
               and |b| = 128

           2.  C_(i,j) || C_(i,j+1) || ... || C_(i,j+7) = AES128(seed_A,
               b), where each matrix coefficient C_(i,j) is a 16-bit
               string interpreted as a nonnegative integer in the
               little-endian byte order, such that C_(i,j) = (c_0, c_1,
               ...,c_15) \equiv c_0 * 2^0 + c_1 *\ 2^1 + ... + c_15 *\
               2^15

           3.  For k = 0 to 7 do

               1.  A_(i,j+k) = C_(i,j+k) mod q

           4.  End for

       2.  End for

   2.  End for

   3.  Output A

6.6.2.  Matrix A generation with SHAKE128

   The algorithm for the case using SHAKE128 is shown below.  Each call
   to SHAKE128 generates n coefficients (i.e., a full matrix row).

   1.  For i = 0 to n - 1 do

       1.  b = i||seed_A, where i is encoded as a 16-bit string
           represented in the little-endian byte order such that (i_0,
           i_1 , ..., i_15) \equiv i_0 * 2^0 + i_1 * 2^1 + ... + i_15 *\
           2^15, and hence the bitlength of b is |b| = lenA+16

       2.  C_(i,0) || C_(i,1) || ... || C_(i,n-1) = SHAKE128(b, 16*n),
           where each matrix coefficient C_(i,j) is a 16-bit string
           interpreted as a nonnegative integer in the little-endian
           byte order, such that C_(i,j) = (c_0, c_1, ..., c_15)\equiv
           c_0 * 2^0 + c_1 *\ 2^1 + ... + c_15 *\ 2^15

       3.  For j = 0 to n - 1 do

           1.  A_(i,j) = C_(i,j) mod q

       4.  End for

   2.  End for

   3.  Output A

7.  FrodoKEM

7.1.  Key Generation

   The key generation algorithm accepts no input, requires randomness,
   and outputs the keypair (pk, sk) = (seedA || b, s || seedA || b ||
   S^T || pkh).

   1.   Choose uniformly random seeds s, seedSE and z of bitlengths
        lensec, lenSE and lenA (resp.)

   2.   Generate pseudorandom seed seedA = SHAKE(z, lenA)

   3.   Generate the matrix A = Gen(seedA)

   4.   Generate pseudorandom bit string (r^(0), r^(1), ..., r^(2*n*nHat
        - 1)) = SHAKE(0x5F || seedSE, 32*n*nHat)

   5.   Sample error matrix S^T = SampleMatrix((r^(0), r^(1), ...,
        r^(n*nHat − 1)), nHat, n)

   6.   Sample error matrix E = SampleMatrix((r^(n*nHat), r^(n*nHat +
        1), ..., r^(2*n*nHat − 1)), n, nHat)

   7.   Compute matrix B = A*S + E

   8.   Compute b = Pack(B)

   9.   Compute pkh = SHAKE(seedA || b, lensec)

   10.  Return public key pk = (seedA || b) and secret key sk = (s ||
        seedA || b || S^T || pkh).  ST = S^T is encoded row-by-row from
        ST_(0,0) to ST_(nHat−1,n−1), where each matrix coefficient
        ST_(i,j) is a signed integer encoded as a 16-bit string in the
        little-endian byte order such that (s_0, s_1, ..., s_15) =
        ST_(i,j) = −s_15 * 2^15 + (s_0 + s_1 * 2 + s_2 * 2^2 + ... +
        s_14 * 2^14)

7.2.  Encapsulation

   The encapsulation algorithm takes as input a public key pk =
   (seedA || b), and outputs a ciphertext c = (c1 || c2 || salt) and a
   shared secret ss.

   1.   Choose uniformly random values u and salt of bitlengths lensec
        and lensalt (resp.)

   2.   Compute pkh = SHAKE(pk, lensec)

   3.   Generate pseudorandom values seedSE || k = SHAKE(pkh || u ||
        salt, lenSE+lensec)

   4.   Generate pseudorandom bit string (r^(0), r^(1), ..., r^(2*nHat*n
        + nHat^2 - 1)) = SHAKE(0x96 || seedSE, 16(2*nHat*n + nHat^2))

   5.   Sample error matrix S' = SampleMatrix((r^(0), r^(1), ...,
        r^(nHat*n - 1)), nHat, n)

   6.   Sample error matrix E' = SampleMatrix((r^(nHat*n), r^(nHat*n +
        1), ..., r^(2*nHat*n - 1)), nHat, n)

   7.   Generate the matrix A = Gen(seedA)

   8.   Compute matrix B' = S'*A + E'

   9.   Compute c1 = Pack(B')

   10.  Sample error matrix E" = SampleMatrix((r^(2*nHat*n), r^(2*nHat*n
        + 1), ..., r^(2*nHat*n + nHat^2 - 1)), nHat, nHat)

   11.  Compute matrix B = Unpack(b, n, nHat)

   12.  Compute matrix V = S'*B + E"

   13.  Compute matrix C = V + Encode(u)

   14.  Compute c2 = Pack(C)

   15.  Compute ss = SHAKE(c1 || c2 || salt ||k, lensec)

   16.  Return ciphertext c = (c1 || c2 || salt) and shared secret ss

7.3.  Decapsulation

   The decapsulation algorithm takes as input a ciphertext c = (c1 ||
   c2 || salt) and a secret key sk = (s || seedA || b || S^T || pkh),
   and outputs a shared secret ss.

   1.   Compute matrix B' = Unpack(c1, nHat, n)

   2.   Compute matrix C = Unpack(c2, nHat, nHat)

   3.   Compute matrix M = C - B'*S

   4.   Compute u' = Decode(M)

   5.   Generate pseudorandom values seedSE' || k' = SHAKE(pkh ||
        u' ||salt, lenSE+lensec)

   6.   Generate pseudorandom bit string (r^(0), r^(1), ..., r^(2*nHat*n
        + nHat^2 - 1)) = SHAKE(0x96 || seedSE', 16 (2*nHat*n + nHat^2))

   7.   Sample error matrix S' = SampleMatrix((r^(0), r^(1), ...,
        r^(nHat*n - 1)), nHat, n)

   8.   Sample error matrix E' = SampleMatrix((r^(nHat*n), r^(nHat*n +
        1), ..., r^(2*nHat*n - 1)), nHat, n)

   9.   Generate the matrix A = Gen(seedA)

   10.  Compute matrix B" = S'*A + E'

   11.  Sample error matrix E" = SampleMatrix((r^(2*nHat*n), r^(2*nHat*n
        + 1), ..., r^(2*nHat*n+ nHat^2 - 1)), nHat, nHat)

   12.  Compute matrix B = Unpack(b, n, nHat)

   13.  Compute matrix V = S'*B + E"

   14.  Compute matrix C' = V + Encode(u')

   15.  If B' = B" and C = C' then kHat = k' else kHat = s

   16.  Compute ss = SHAKE(c1 || c2 || salt || kHat, lensec)

   17.  Return shared secret ss

8.  FrodoKEM variants

   FrodoKEM is parameterized by the pseudorandom generator (PRG) that is
   used for the generation of the matrix A.  As explained in
   Section XXXX there are two options for PRG: AES128 and SHAKE128.

   In addition, FrodoKEM consists of two main variants: a "standard"
   variant that does not impose any restriction on the reuse of key
   pairs, and an "ephemeral" variant that is intended for applications
   in which the number of ciphertexts produced relative to any single
   public key is small.  Concretely, the use of standard FrodoKEM is
   recommended for applications in which the number of ciphertexts
   produced for a single public key is expected to be equal or greater
   than 2^8.  Ephemeral FrodoKEM shall be used for applications in which
   that same figure is expected to be smaller than 2^8.

9.  Parameter Sets

   This document specifies the following twelve parameter sets:

   1.  FrodoKEM-640-⟨PRG⟩ and eFrodoKEM-640-⟨PRG⟩, which match or exceed
       the brute-force security of AES128.

   2.  FrodoKEM-976-⟨PRG⟩ and eFrodoKEM-976-⟨PRG⟩, which match or exceed
       the brute-force security of AES192.

   3.  FrodoKEM-1344-⟨PRG⟩ and eFrodoKEM-1344-⟨PRG⟩, which match or
       exceed the brute-force security of AES256.

   The label "eFrodoKEM" corresponds to the ephemeral variants.  The
   options for ⟨PRG⟩ are AES or SHAKE, when either AES128 or SHAKE128
   (respectively) is used for the generation of the matrix A.  Thus, the
   first FrodoKEM variant consists of the parameter sets FrodoKEM-
   640-AES, FrodoKEM-976-AES and FrodoKEM-1344-AES (and their
   corresponding ephemeral variants).  The second FrodoKEM variant
   consists of the parameter sets FrodoKEM-640-SHAKE, FrodoKEM-976-SHAKE
   and FrodoKEM-1344-SHAKE (and their corresponding ephemeral variants).

9.1.  Parameters

9.2.  Aligned Table

   | Left Aligned | Center Aligned | Right
   Aligned | |:-------------|:--------------:|--------------:| | Item
   1 | Item 2 | Item 3 | | Item 4 | Item 5 | Item 6 | | Item 7 | Item
   8 | Item 9 |

   +======+==============+==============+==============+==============+
   |  Name| (e)FrodoKEM- | (e)FrodoKEM- | (e)FrodoKEM- | Description  |
   |      |     640      |     976      |     1344     |              |
   +======+==============+==============+==============+==============+
   |     D|      15      |      16      |      16      | Bitlength of |
   |      |              |              |              | q            |
   +------+--------------+--------------+--------------+--------------+
   |     q|    32768     |    65536     |    65536     | Power-of-two |
   |      |              |              |              | integer      |
   |      |              |              |              | modulus      |
   +------+--------------+--------------+--------------+--------------+
   |     n|     640      |     976      |     1344     | Integer      |
   |      |              |              |              | matrix       |
   |      |              |              |              | dimension    |
   +------+--------------+--------------+--------------+--------------+
   |  nHat|      8       |      8       |      8       | Integer      |
   |      |              |              |              | matrix       |
   |      |              |              |              | dimension    |
   +------+--------------+--------------+--------------+--------------+
   |     B|      2       |      3       |      4       | Number of    |
   |      |              |              |              | bits encoded |
   |      |              |              |              | per matrix   |
   |      |              |              |              | entry        |
   +------+--------------+--------------+--------------+--------------+
   |     d|      12      |      10      |      6       | Integer      |
   |      |              |              |              | defining the |
   |      |              |              |              | support of X |
   +------+--------------+--------------+--------------+--------------+
   |  lenA|     128      |     128      |     128      | Bitlength of |
   |      |              |              |              | seeds for    |
   |      |              |              |              | generation   |
   |      |              |              |              | of matrix A  |
   +------+--------------+--------------+--------------+--------------+
   |lensec|     128      |     192      |     256      | Number of    |
   |      |              |              |              | bits         |
   |      |              |              |              | matching the |
   |      |              |              |              | bit-security |
   |      |              |              |              | level        |
   +------+--------------+--------------+--------------+--------------+
   | SHAKE|   SHAKE128   |   SHAKE256   |   SHAKE256   | SHAKE        |
   |      |              |              |              | variant used |
   |      |              |              |              | for hashing  |
   +------+--------------+--------------+--------------+--------------+

                                 Table 1

                                       Table 1: Parameters for FrodoKEM.

   +=========+=================+==================+==================+==
   ==============================================+ | Name |
   FrodoKEM-640 | FrodoKEM-976 | FrodoKEM-1344 | Description | +========
   =+=================+==================+==================+===========
   =====================================+ | lenSE | 256 | 384 | 512 |
   Bitlength of seedSE in FrodoKEM | +---------+-----------------+------
   ------------+------------------+-------------------------------------
   -----------+ | lensalt | 256 | 384 | 512 | Bitlength of salt in
   FrodoKEM | +=========+=======+=======================================
   =========================================================+ | Name |
   eFrodoKEM-640 | eFrodoKEM-976 | eFrodoKEM-1344 | Description | +=====
   ====+=================+==================+==================+========
   ========================================+ | lenSE | 128 | 192 | 256 |
   Bitlength of seedSE in eFrodoKEM | +---------+-----------------+-----
   -------------+------------------+------------------------------------
   ------------+ | lensalt | 0 | 0 | 0 | No salt in eFrodoKEM | +-------
   --+-----------------+------------------+------------------+----------
   --------------------------------------+

                       Table 2: Additional parameters for FrodoKEM depending on variant.

   +===============+================+================+=================+
    | Table entries | FrodoKEM-640 | FrodoKEM-976 | FrodoKEM-1344 | +===
   ============+================+================+=================+ |
   T_X(0) | 4,643 | 5,638 | 9,142 | +---------------+----------------+--
   --------------+-----------------+ | T_X(1) | 13,363 | 15,915 |
   23,462 | +---------------+----------------+----------------+---------
   --------+ | T_X(2) | 20,579 | 23,689 | 30,338 | +---------------+----
   ------------+----------------+-----------------+ | T_X(3) | 25,843 |
   28,571 | 32,361 | +---------------+----------------+----------------
   +-----------------+ | T_X(4) | 29,227 | 31,116 | 32,725 | +----------
   -----+----------------+----------------+-----------------+ | T_X(5) |
   31,145 | 32,217 | 32,765 | +---------------+----------------+--------
   --------+-----------------+ | T_X(6) | 32,103 | 32,613 | 32,767 | +--
   -------------+----------------+----------------+-----------------+ |
   T_X(7) | 32,525 | 32,731 | | +---------------+----------------+------
   ----------+-----------------+ | T_X(8) | 32,689 | 32,760 | | +-------
   --------+----------------+----------------+-----------------+ |
   T_X(9) | 32,745 | 32,766 | | +---------------+----------------+------
   ----------+-----------------+ | T_X(10) | 32,762 | 32,767 | | +------
   ---------+----------------+----------------+-----------------+ |
   T_X(11) | 32,766 | | | +---------------+----------------+------------
   ----+-----------------+ | T_X(12) | 32,767 | | |
   +---------------+----------------+----------------+-----------------+

              Table 3: The distribution table entries T_X(i),
                       for 0 <= i <= d, for sampling.

   +================+=================+=================+===============
   ==+==================+ | | secret key sk | public key pk | ciphertext
   ct | shared secret ss | +================+=================+=========
   ========+=================+==================+ | FrodoKEM-640 |
   19,888 | 9,616 | 9,752 | 16 | +----------------+-----------------+---
   --------------+-----------------+------------------+ |
   eFrodoKEM-640 | 19,888 | 9,616 | 9,720 | 16 | +----------------+-----
   ------------+-----------------+-----------------+------------------
   + | FrodoKEM-976 | 31,296 | 15,632 | 15,792 | 24 | +----------------
   +-----------------+-----------------+-----------------+--------------
   ----+ | eFrodoKEM-976 | 31,296 | 15,632 | 15,744 | 24 | +------------
   ----+-----------------+-----------------+-----------------+----------
   --------+ | FrodoKEM-1344 | 43,088 | 21,520 | 21,696 | 32 | +--------
   --------+-----------------+-----------------+-----------------+------
   ------------+ | eFrodoKEM-1344 | 43,088 | 21,520 | 21,632 | 32 | +---
   -------------+-----------------+-----------------+-----------------+-
   -----------------+

                       Table 4: Sizes (in bits) of inputs and outputs.

10.  Security Considerations

   FrodoKEM-640, FrodoKEM-976 and FrodoKEM-1344 are designed to be post-
   quantum IND-CCA2 secure KEMs at the security levels of AES-128,
   AES-192 and AES-256, respectively.

   Users are recommended to use the highest possible security level that
   a given application allows.  In particular, the designers of FrodoKEM
   recommend to use either FrodoKEM-976 or FrodoKEM-1344 for most
   applications, and limit the use of FrodoKEM-640 to applications that
   require short-term security.

   Lattice-based cryptographic schemes such as FrodoKEM are still
   relatively young.  Therefore, it is recommended to use FrodoKEM in
   combination with a classical scheme (e.g., based on elliptic curves)
   while our confidence in the security of lattice schemes increases
   over time.

11.  IANA Considerations

   This document has no IANA actions.

12.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

Acknowledgments

   TODO acknowledge.

Author's Address

   Your Name Here
   Your Organization Here
   Email: your.email@example.com
